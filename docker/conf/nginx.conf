daemon off;
user daemon;
worker_processes auto;

events {
    worker_connections  1024;
}

env PROXY1_PORT_80_TCP_ADDR;
env PROXY1_PORT_80_TCP_PORT;
env PROXY2_PORT_80_TCP_ADDR;
env PROXY2_PORT_80_TCP_PORT;
env PROXY3_PORT_80_TCP_ADDR;
env PROXY3_PORT_80_TCP_PORT;

http {
    include       mime.types;
    default_type  application/octet-stream;

    mruby_init_worker_code '
            Userdata.new.redis = Redis.new "redis", 6379
    ';


    mruby_init_code '
        secret_token = SecureRandom.uuid

        # Setup dehydrated example
        #
        # cp -pr ngx_mruby/test/conf/auto-ssl ${NGINX_INSTALL_DIR}/conf/.
        # sudo chown nginx -R ${NGINX_INSTALL_DIR}/conf/auto-ssl

        Userdata.new.dehydrated_opts = {
                            bin: "/usr/local/nginx/conf/auto-ssl/dehydrated",
                            conf: "/usr/local/nginx/conf/auto-ssl/dehydrated.conf",
                            hook: "/usr/local/nginx/conf/auto-ssl/ngx_mruby-hook.sh",
                            secret_token: secret_token,
                          }

        Userdata.new.allow_domains = %w(
                            autossl.internal.levii.co.jp
                            hoge.internal.levii.co.jp
                            fuga.internal.levii.co.jp
                          )

        Userdata.new.auto_ssl_secret = secret_token
        Userdata.new.auto_ssl_port = 11111
    ';

    sendfile        on;
    keepalive_timeout  65;

    server {
        listen       443 ssl;
        server_name _;

        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers HIGH:!aNULL:!MD5;
        ssl_certificate __NGXDOCROOT__/dummy.crt;
        ssl_certificate_key __NGXDOCROOT__/dummy.key;

        mruby_ssl_handshake_handler_code '
          ssl = Nginx::SSL.new
          domain = ssl.servername
          acme = Nginx::SSL::ACME.new domain, Userdata.new.dehydrated_opts, Userdata.new.allow_domains

          raise "not allowed servername" unless acme.allow_domain?

          redis = Userdata.new.redis
          if redis["#{domain}.crt"].nil? or redis["#{domain}.key"].nil?
            acme.auto_cert_deploy
          end

          ssl.certificate_data = redis["#{domain}.crt"]
          ssl.certificate_key_data = redis["#{domain}.key"]
        ';

        location / {
            mruby_content_handler_code 'Nginx.rputs "hello #{Nginx::Request.new.hostname} world!"';
        }
    }


    server {
        listen 80;
        server_name _;

        location ^~ /.well-known/acme-challenge/ {
            mruby_content_handler_code '

              Nginx.return -> do
                r = Nginx::Request.new
                redis = Userdata.new.redis
                access_token = Nginx::SSL::ACME.token_filename_from_url(r)
                stored_token = redis["#{r.hostname}_token_filename"]

                if access_token != stored_token
                  Nginx.log Nginx::LOG_ERR, "ACME challenge token not found"
                  Nginx.log Nginx::LOG_ERR, "access token: #{access_token}"
                  Nginx.log Nginx::LOG_ERR, "stored token: #{stored_token}"
                  return Nginx::HTTP_NOT_FOUND
                end

                Nginx.rputs redis["#{r.hostname}_token_value"]
              end.call
            ';
        }

        location /mruby-hello {
            mruby_content_handler_code 'Nginx.echo "server ip: #{Nginx::Connection.new.local_ip}: hello ngx_mruby world."';
        }

        location /mruby-test {
            mruby_content_handler /usr/local/nginx/hook/test.rb;
        }

        location /mruby-proxy {
            mruby_set $backend /usr/local/nginx/hook/proxy.rb;
            proxy_pass http://$backend;
        }

	location /mruby-redis-set {
		mruby_content_handler_code '
			r = Nginx::Request.new
			redis = Userdata.new.redis
			redis.set("hoge", r.hostname)
			Nginx.rputs "nginx redis set."
		';
	}

	location /mruby-redis {
		mruby_content_handler_code '
			redis = Userdata.new.redis
			Nginx.rputs "nginx redis hoge : #{redis["hoge"]}"
		';
	}

        # test for Nginx::Var
        # http://localhost/nginx_var?name=http_host
        location /nginx_var {
            mruby_content_handler_code '
              r = Nginx::Request.new
              Nginx.echo r.var.send r.var.arg_name.to_sym
              Nginx.return Nginx::HTTP_OK
            ';
        }

        location = /.well-known/acme-challenge/ {
           return 404;
        }
    }

    server {
        listen 127.0.0.1:11111;
        server_name localhost;

        location /deploy-cert {
            mruby_enable_read_request_body on;
            mruby_content_handler_code '

              Nginx.log Nginx::LOG_INFO, "handle /deploy-cert ..."

              Nginx.return -> do
                r = Nginx::Request.new

                Nginx.log Nginx::LOG_INFO, "Userdata.new.auto_ssl_secret = #{Userdata.new.auto_ssl_secret}"
                Nginx.log Nginx::LOG_INFO, "Nginx::SSL::ACME.secret_token(r) = #{Nginx::SSL::ACME.secret_token(r)}"


                if Userdata.new.auto_ssl_secret == Nginx::SSL::ACME.secret_token(r)
                  cert_info = Nginx::SSL::ACME.deploy_cert_information r
                  Nginx.log Nginx::LOG_INFO, "cert_info = #{cert_info}"
                  redis = Userdata.new.redis
                  redis.mset "#{cert_info[:domain]}.key", cert_info[:key], "#{cert_info[:domain]}.crt", cert_info[:crt]
                  Nginx.rputs "deploy cert ok"
                  return Nginx::HTTP_OK
                end

                return Nginx::HTTP_UNAUTHORIZED
              end.call
            ';
        }

        location /deploy-challenge {
            mruby_enable_read_request_body on;
            mruby_content_handler_code '
              Nginx.log Nginx::LOG_INFO, "handle /deploy-challenge ..."

              Nginx.return -> do
                r = Nginx::Request.new

                Nginx.log Nginx::LOG_INFO, "Userdata.new.auto_ssl_secret = #{Userdata.new.auto_ssl_secret}"
                Nginx.log Nginx::LOG_INFO, "Nginx::SSL::ACME.secret_token(r) = #{Nginx::SSL::ACME.secret_token(r)}"

                if Userdata.new.auto_ssl_secret == Nginx::SSL::ACME.secret_token(r)
                  domain = Nginx::SSL::ACME.challenged_domain r
                  Nginx.log Nginx::LOG_INFO, "#{domain}_token_filename = #{Nginx::SSL::ACME.challenged_token_filename r}"
                  Nginx.log Nginx::LOG_INFO, "#{domain}_token_value = #{Nginx::SSL::ACME.challenged_token_value r}"

                  redis = Userdata.new.redis
                  redis["#{domain}_token_filename"] = Nginx::SSL::ACME.challenged_token_filename r
                  redis["#{domain}_token_value"] = Nginx::SSL::ACME.challenged_token_value r
                  Nginx.rputs "depoy challenge ok"
                  return Nginx::HTTP_OK
                end

                return Nginx::HTTP_UNAUTHORIZED
              end.call
            ';
        }

        location / {
            mruby_content_handler_code "Nginx.rputs 'hello 11111 world'";
        }
    }
}
